#!/usr/bin/env python3

# Copyright (c) 2024 Jet Propulsion Laboratory. All rights reserved.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import yaml as pyyaml
import datetime
import sys

FILE_HEADER = f"""# Path: shared/db/entities/<table_type>.py
# This file is automatically generated by CORTEX/utils/table_generator.py

# Copyright (c) {datetime.datetime.now().year} Jet Propulsion Laboratory. All rights reserved.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#
#       https://www.apache.org/licenses/LICENSE-2.0
#
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

"""

SQLALCHEMY_IMPORT_TEMPLATE = """from sqlalchemy import Column, Integer, String, DateTime, Index, ARRAY, ForeignKey, DOUBLE_PRECISION
from sqlalchemy.orm import declarative_base

Base = declarative_base()
"""

SQLALCHEMY_TEMPLATE = """class CLASS_NAME(Base):
    __tablename__ = TABLE_NAME
    __table_args__ = ({TABLE_ARGS})

    COLUMNS

    def __repr__(self):
        return REPRESENTATION


INDICES
"""

TEST_SCRIPT = """
if __name__ == '__main__':
    from sqlalchemy import create_engine
    engine = create_engine('timescaledb://postgres:postgres@localhost:5432/postgres')
    Base.metadata.create_all(engine)
"""



class CRTXTableGenerator:
    # Class for generating SQLAlchemy code from CRTX table config
    def __init__(self):
        # List of valid CRTX types
        self.__base_types = ['String', 'Int64', 'Float64']
        self.__array_types = [base_type + '[]' for base_type in self.__base_types]
        self.__column_types = self.__base_types + self.__array_types + ['DateTime']

        # Map CRTX types to SQLAlchemy types
        self.__type_map = {
            'String': 'String',
            'Int64': 'Integer',
            'Float64': 'DOUBLE_PRECISION',
            'DateTime': 'DateTime(timezone=True)'
        }
        for array_type in self.__array_types:
            self.__type_map[array_type] = f'ARRAY({self.__type_map[array_type[:-2]]})'

        # List of valid column qualifiers
        self.__qualifiers = [
            'Nullable',
            'Unique'
        ]

    def parse(self, table_yaml: str):
        # Convert YAML to python array of table config objects
        tables = pyyaml.load(table_yaml, Loader=pyyaml.FullLoader)
        return tables

    def generate(self, table_config: dict, table_type: str = 'hypertable'):
        # Convert python dict to SQLAlchemy code

        # Since the name config may contain multiple table names, we need to split them up
        # and create code for each table name (code will be the same for each table name)
        table_prefix = 'ts' if table_type == 'hypertable' else 'rel'
        table_args = """'timescaledb_hypertable': {'time_column_name': 'time', 'chunk_time_interval': '1 day'}""" if table_type == 'hypertable' else ''
        table_names = self.__get_table_names(table_config)

        columns = self.__get_columns(table_config, table_type)

        # Create SQLAlchemy code for each table name
        sqlalchemy_code = []
        for table_name in table_names:
            code = f"{SQLALCHEMY_TEMPLATE}"
            class_name_tokens = table_name.split('_')
            class_name = ''.join([token.capitalize() for token in class_name_tokens])
            qualifiers = self.__get_table_qualifiers(table_config, table_name)

            if len(qualifiers) > 0:
                code = code.replace('INDICES', '\n'.join(qualifiers))
            else:
                code = code.replace('INDICES', '')
            code = code.replace('CLASS_NAME', f"{class_name}")
            code = code.replace('TABLE_NAME', f"'{table_prefix}_{table_name}'")
            code = code.replace('TABLE_ARGS', table_args)
            code = code.replace('COLUMNS', '\n    '.join(columns))

            # Create printable representation using class name, column_name=self.column_value
            representation = f'f"""<{class_name}('
            for column in columns:
                column_name = column.split('=')[0].strip()
                representation += f"{column_name}='{{self.{column_name}}}', "
            representation = representation[:-2] + ')>"""'
            code = code.replace('REPRESENTATION', representation)

            sqlalchemy_code.append(code)

        return sqlalchemy_code

    def __get_columns(self, table_config: dict, table_type: str = 'hypertable'):
        # Get columns from table config
        columns = []

        if table_type == 'hypertable':
            # If hypertable, include the `time` and `msg_time` columns
            columns.append("time = Column(DateTime(timezone=True), nullable=False, primary_key=True)")
            columns.append("msg_time = Column(DateTime(timezone=True), nullable=True)")
        else:
            # Otherwise, add an auto-incrementing primary key
            columns.append("id = Column(Integer, primary_key=True, autoincrement=True)")

        # Get value of the first element in the dict (since the dict only has one element)
        table_config = table_config[list(table_config.keys())[0]]

        for column_name, column_type in table_config.items():
            if 'indices' not in column_name and 'foreign_key' not in column_name:
                column_type, column_qualifiers = self.__parse_column(column_type)
                column_args = ''
                for qualifier in column_qualifiers:
                    column_args += f"{qualifier.lower()}=True, "

                # If nullable qualifier is not present, set it to false
                if 'nullable' not in column_args:
                    column_args += 'nullable=False'

                # Only add ', column_args' if column_args is not empty
                columns.append(f"{column_name} = Column({column_type}{', ' + column_args if column_args else ''})")
        return columns

    def __parse_column(self, column_type: str):
        tokens = column_type.split(',')

        # Validate column type
        if tokens[0] not in self.__column_types:
            raise ValueError(f"Invalid column type: {column_type}")

        column_type = self.__type_map[tokens[0]]
        column_qualifiers = tokens[1:] if len(tokens) > 1 else []

        # Remove whitespace from column qualifiers
        column_qualifiers = [qualifier.strip() for qualifier in column_qualifiers]

        # Validate column qualifiers
        for qualifier in column_qualifiers:
            if qualifier not in self.__qualifiers:
                raise ValueError(f"Invalid column qualifier: {qualifier}")

        return column_type, column_qualifiers

    def __get_table_qualifiers(self, table_config: dict, table_name: str):
        # Get table qualifiers from table config
        qualifiers = []
        table_config = table_config[list(table_config.keys())[0]]

        # Get column names to ensure the indices are valid
        column_names = [column_name for column_name in table_config.keys() if
                        'indices' not in column_name and 'foreign_key' not in column_name]

        for column_name, column_type in table_config.items():
            if 'indices' in column_name:
                indices = self.__parse_indices(column_type)

                for index in indices:
                    try:
                        self.__validate_index(index, column_names, table_name)
                    except ValueError as e:
                        # Print a warning to stderr and continue
                        print(f"WARNING: {e}", file=sys.stderr)
                        continue

                    idx_name = f"idx_{table_name}_{index.replace('CLASS_NAME.', '')}"
                    idx_name = idx_name.replace(', ', '_')
                    index_code = f"Index('{idx_name}', {''.join(index)})"
                    qualifiers += [index_code]
        return qualifiers

    def __validate_index(self, index: str, column_names: list, table_name):
        # Get column names from the indexes, which may be comma separated
        index_tokens = index.split(',')
        index_tokens = [token.strip() for token in index_tokens]

        # Get the part after the dot (e.g. CLASS_NAME.time -> time)
        index_tokens = [token.split('.')[-1] for token in index_tokens]

        # Check if all index tokens are valid column names
        for token in index_tokens:
            # If token is an empty string, yell at the user
            if token == '':
                # Print warning to stderr and continue
                print(f"WARNING: Found empty string in {table_name} index configuration...", file=sys.stderr)
            if token not in column_names:
                raise ValueError(f"Invalid index configuration, {table_name}.{token} does not exist! Skipping...")

    def __parse_indices(self, qualifier: str):
        # Get indices from qualifier
        tokens = qualifier.split(',')
        indices = [index.strip() for index in tokens]
        index_args = []

        for index in indices:
            if '+' in index:
                index_tokens = index.split('+')
                index_tokens = [token.strip() for token in index_tokens]
                index_tokens = [f"CLASS_NAME.{token}" for token in index_tokens]
                index = ', '.join(index_tokens)
            else:
                index = f"CLASS_NAME.{index}"

            index_args.append(index)
        return index_args

    def __get_table_names(self, table_dict: dict):
        # Get table names from dict
        table_names = []
        for table_name in table_dict.keys():
            if ',' in table_name:
                table_names += table_name.split(',')

                # Remove all characters not in [a-zA-Z_]
                table_names = [''.join([char for char in name if char.isalpha() or char == '_']) for name in
                               table_names]

                # Remove whitespace and convert to lowercase
                table_names = [name.strip().lower() for name in table_names]
            else:
                table_names.append(table_name)
        return sorted(list(set(table_names)))

    def __call__(self, *args, **kwargs):
        return self.generate(*args, **kwargs)


if __name__ == '__main__':
    gen = CRTXTableGenerator()

    # Get path of this script
    import os

    script_path = os.path.dirname(os.path.realpath(__file__))

    # Get yaml files in ../config/timescaledb/tables
    yaml_dir = os.path.join(script_path, '../config/timescaledb/tables')
    yaml_files = [os.path.join(yaml_dir, file) for file in os.listdir(yaml_dir) if file.endswith('.yaml')]

    # Resolve files to absolute paths
    yaml_files = [os.path.abspath(file) for file in yaml_files]

    print(f"Found {len(yaml_files)} yaml files in {yaml_dir}")

    # Parse yaml files and generate SQLAlchemy code
    for yaml_file in yaml_files:
        with open(yaml_file, 'r') as file:
            yaml = file.read()

        table_type = 'hypertable' if 'timeseries' in yaml_file else 'relational'
        table_configs = gen.parse(yaml)

        # Remove existing files at ../shared/db/entities/<table_type>.py
        output_file = os.path.join(script_path, f"../shared/db/entities/{table_type}.py")
        output_file = os.path.abspath(output_file)

        if os.path.exists(output_file):
            os.remove(output_file)

        # Create a new file at ../shared/db/entities/<table_type>.py
        open(output_file, 'a').close()
        print(f"Writing to {output_file}")

        # Write file header and import statement
        with open(output_file, 'a') as file:
            file.write(FILE_HEADER.replace('<table_type>', table_type))
            file.write(SQLALCHEMY_IMPORT_TEMPLATE)

        for table_config in table_configs:
            sqlalchemy_code = gen(table_config, table_type)

            with open(output_file, 'a') as file:
                file.write('\n\n')
                file.write('\n'.join(sqlalchemy_code))

        # Write test stump
        with open(output_file, 'a') as file:
            file.write('\n\n')
            file.write(TEST_SCRIPT)

        print(f"Finished writing to {output_file}")
